#include <iostream>

#include "Utils.h"
#include "DrawShader.h"

using namespace std;

DrawShader::DrawShader(string vertexShaderPath, string fragmentShaderPath)
{
	Shader = Utils::createShaderVF(vertexShaderPath, fragmentShaderPath);
}

DrawShader::DrawShader(string vertexShaderPath, string fragmentShaderPath, string geometryShaderath)
{
	Shader = Utils::createShaderVFG(vertexShaderPath, fragmentShaderPath, geometryShaderath);
}


DrawShader::~DrawShader()
{
	glDeleteProgram(Shader);
}

void DrawShader::setUniformBoolen(const string& name, bool v0)
{
	glUniform1i(getUniformLocation(name), v0);
}


void DrawShader::setUniform1i(const string& name, int v0)
{
	glUniform1i(getUniformLocation(name), v0);
}

void DrawShader::setUniform1f(const string& name, float v0)
{
	glUniform1f(getUniformLocation(name), v0);
}

void DrawShader::setUniform3f(const string& name, float v0, float v1, float v2)
{
	glUniform3f(getUniformLocation(name), v0, v1, v2);
}

void DrawShader::setUniform4f(const string& name, float v0, float v1, float v2, float v3)
{
	glUniform4f(getUniformLocation(name), v0, v1, v2, v3);
}

void DrawShader::setUniformVec2(const string& name, glm::vec2 value)
{
	glUniform3fv(getUniformLocation(name), 1, &value[0]);
}

void DrawShader::setUniformVec3(const string& name, glm::vec3 value)
{
	glUniform3fv(getUniformLocation(name), 1, &value[0]);
}

void DrawShader::setUniformVec4(const string& name, glm::vec4 value)
{
	glUniform4fv(getUniformLocation(name), 1, &value[0]);
}


void DrawShader::setUniformMat4f(const string& name, const glm::mat4 matrix)
{
	glUniformMatrix4fv(getUniformLocation(name), 1, GL_FALSE, &matrix[0][0]);
}

GLint DrawShader::getUniformLocation(const string& location)
{
	if (m_UniformLocationCache.find(location) != m_UniformLocationCache.end())									// 找到，返回当前元素位置，未找到，返回哈希表.end()位置
		return m_UniformLocationCache[location];																// .end() 最后一个元素的下一个位置																	

	GLint Location_new = glGetUniformLocation(Shader, location.c_str());
	if (Location_new == GL_INVALID_VALUE)
	{
		cout << "error:" << Shader << "program is not a value generated by OpenGL \n" << endl;
	}

	if (Location_new == GL_INVALID_VALUE)
	{
		cout << "error:" << Shader << "program is not a program object \n" << endl;
	}

	else if (Location_new == GL_INVALID_OPERATION)
	{
		cout << "error:" << Shader << "program has not been successfully linked \n" << endl;
	}

	else if (Location_new == -1)
	{
		cout << "Warning: uniform  " << location << "  doesn't exist! \n" << endl;
	}

	m_UniformLocationCache[location] = Location_new;

	return Location_new;
}

void DrawShader::bind()const
{

	glUseProgram(Shader);
}

void DrawShader::unbind()const
{
	glUseProgram(0);
}

void DrawShader::display(int count)const													// 按顶点绘制 GL_TRIANGLES，起始位置默认为0 ，count 边数
{
	glDrawArrays(GL_TRIANGLES, 0, count);
}

void DrawShader::displays(int count)const													//  按索引绘制  count 索引数
{
	glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_INT, NULL);															
}